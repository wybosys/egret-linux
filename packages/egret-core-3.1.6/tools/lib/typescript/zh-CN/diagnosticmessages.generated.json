{
  "Unterminated_string_literal_1002": "未终止的字符串文本。",
  "Identifier_expected_1003": "应为标识符。",
  "_0_expected_1005": "应为“{0}”。",
  "A_file_cannot_have_a_reference_to_itself_1006": "文件不能引用自身。",
  "Trailing_comma_not_allowed_1009": "不允许使用尾随逗号。",
  "Asterisk_Slash_expected_1010": "应为 \"*/\"。",
  "Unexpected_token_1012": "意外的标记。",
  "A_rest_parameter_must_be_last_in_a_parameter_list_1014": "rest 参数必须是参数列表中的最后一个参数。",
  "Parameter_cannot_have_question_mark_and_initializer_1015": "参数不能包含问号和初始化表达式。",
  "A_required_parameter_cannot_follow_an_optional_parameter_1016": "必选参数不能位于可选参数后。",
  "An_index_signature_cannot_have_a_rest_parameter_1017": "索引签名不能包含 rest 参数。",
  "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018": "索引签名参数不能具有可访问性修饰符。",
  "An_index_signature_parameter_cannot_have_a_question_mark_1019": "索引签名参数不能包含问号。",
  "An_index_signature_parameter_cannot_have_an_initializer_1020": "索引签名参数不能具有初始化表达式。",
  "An_index_signature_must_have_a_type_annotation_1021": "索引签名必须具有类型批注。",
  "An_index_signature_parameter_must_have_a_type_annotation_1022": "索引签名参数必须具有类型批注。",
  "An_index_signature_parameter_type_must_be_string_or_number_1023": "索引签名参数类型必须为 \"string\" 或 \"number\"。",
  "Accessibility_modifier_already_seen_1028": "已看到可访问性修饰符。",
  "_0_modifier_must_precede_1_modifier_1029": "“{0}”修饰符必须位于“{1}”修饰符之前。",
  "_0_modifier_already_seen_1030": "已看到“{0}”修饰符。",
  "_0_modifier_cannot_appear_on_a_class_element_1031": "“{0}”修饰符不能出现在类元素上。",
  "super_must_be_followed_by_an_argument_list_or_member_access_1034": "\"super\" 的后面必须是参数列表或成员访问。",
  "Only_ambient_modules_can_use_quoted_names_1035": "仅环境模块可使用带引号的名称。",
  "Statements_are_not_allowed_in_ambient_contexts_1036": "不允许在环境上下文中使用语句。",
  "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038": "不能在已有的环境上下文中使用 \"declare\" 修饰符。",
  "Initializers_are_not_allowed_in_ambient_contexts_1039": "不允许在环境上下文中使用初始化表达式。",
  "_0_modifier_cannot_be_used_in_an_ambient_context_1040": "“{0}”修饰符不能在环境上下文中使用。",
  "_0_modifier_cannot_be_used_with_a_class_declaration_1041": "“{0}”修饰符不能与类声明一起使用。",
  "_0_modifier_cannot_be_used_here_1042": "“{0}”修饰符不能在此处使用。",
  "_0_modifier_cannot_appear_on_a_data_property_1043": "“{0}”修饰符不能出现在数据属性上。",
  "_0_modifier_cannot_appear_on_a_module_element_1044": "“{0}”修饰符不能出现在模块元素上。",
  "A_0_modifier_cannot_be_used_with_an_interface_declaration_1045": "“{0}”修饰符不能与接口声明一起使用。",
  "A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file_1046": "在 .d.ts 文件中的顶层声明需要 \"declare\" 修饰符。",
  "A_rest_parameter_cannot_be_optional_1047": "rest 参数不能为可选参数。",
  "A_rest_parameter_cannot_have_an_initializer_1048": "rest 参数不能具有初始化表达式。",
  "A_set_accessor_must_have_exactly_one_parameter_1049": "\"set\" 访问器必须正好具有一个参数。",
  "A_set_accessor_cannot_have_an_optional_parameter_1051": "\"set\" 访问器不能具有可选参数。",
  "A_set_accessor_parameter_cannot_have_an_initializer_1052": "\"set\" 访问器参数不能包含初始化表达式。",
  "A_set_accessor_cannot_have_rest_parameter_1053": "\"set\" 访问器不能具有 rest 参数。",
  "A_get_accessor_cannot_have_parameters_1054": "\"get\" 访问器不能具有参数。",
  "Type_0_is_not_a_valid_async_function_return_type_1055": "类型“{0}”不是有效的异步函数返回类型。",
  "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056": "访问器仅在面向 ECMAScript 5 和更高版本时可用。",
  "An_async_function_or_method_must_have_a_valid_awaitable_return_type_1057": "异步函数或方法必须具有有效的可等待返回类型。",
  "Operand_for_await_does_not_have_a_valid_callable_then_member_1058": "\"await\" 的操作数不具有有效的可调用 \"then\" 成员。",
  "Return_expression_in_async_function_does_not_have_a_valid_callable_then_member_1059": "异步函数中的返回表达式不具有有效的可调用 \"then\" 成员。",
  "Expression_body_for_async_arrow_function_does_not_have_a_valid_callable_then_member_1060": "异步箭头函数的表达式主体不具有有效的可调用 \"then\" 成员。",
  "Enum_member_must_have_initializer_1061": "枚举成员必须具有初始化表达式。",
  "_0_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062": "{0} 在其自身的 \"then\" 方法的 fulfillment 回调中得到直接或间接引用。",
  "An_export_assignment_cannot_be_used_in_a_namespace_1063": "不能在命名空间中使用导出分配。",
  "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1064": "The return type of an async function or method must be the global Promise<T> type.",
  "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066": "在环境枚举声明中，成员初始化表达式必须是常数表达式。",
  "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068": "意外的标记。应为构造函数、方法、访问器或属性。",
  "A_0_modifier_cannot_be_used_with_an_import_declaration_1079": "“{0}”修饰符不能与导入声明一起使用。",
  "Invalid_reference_directive_syntax_1084": "\"reference\" 指令语法无效。",
  "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_1085": "面向 ECMAScript 5 和更高版本时，八进制文本不可用。",
  "An_accessor_cannot_be_declared_in_an_ambient_context_1086": "不能在环境上下文中声明访问器。",
  "_0_modifier_cannot_appear_on_a_constructor_declaration_1089": "“{0}”修饰符不能出现在构造函数声明中。",
  "_0_modifier_cannot_appear_on_a_parameter_1090": "“{0}”修饰符不能出现在参数中。",
  "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091": "\"for...in\" 语句中只允许单个变量声明。",
  "Type_parameters_cannot_appear_on_a_constructor_declaration_1092": "类型参数不能出现在构造函数声明中。",
  "Type_annotation_cannot_appear_on_a_constructor_declaration_1093": "类型批注不能出现在构造函数声明中。",
  "An_accessor_cannot_have_type_parameters_1094": "访问器不能具有类型参数。",
  "A_set_accessor_cannot_have_a_return_type_annotation_1095": "\"set\" 访问器不能具有返回类型批注。",
  "An_index_signature_must_have_exactly_one_parameter_1096": "索引签名必须正好具有一个参数。",
  "_0_list_cannot_be_empty_1097": "“{0}”列表不能为空。",
  "Type_parameter_list_cannot_be_empty_1098": "类型参数列表不能为空。",
  "Type_argument_list_cannot_be_empty_1099": "类型参数列表不能为空。",
  "Invalid_use_of_0_in_strict_mode_1100": "严格模式下“{0}”的使用无效。",
  "with_statements_are_not_allowed_in_strict_mode_1101": "严格模式下不允许使用 \"with\" 语句。",
  "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102": "在严格模式下，无法对标识符调用 \"delete\"。",
  "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104": "\"continue\" 语句只能在封闭迭代语句内使用。",
  "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105": "\"break\" 语句只能在封闭迭代或 switch 语句内使用。",
  "Jump_target_cannot_cross_function_boundary_1107": "跳转目标不能跨越函数边界。",
  "A_return_statement_can_only_be_used_within_a_function_body_1108": "\"return\" 语句只能在函数体中使用。",
  "Expression_expected_1109": "应为表达式。",
  "Type_expected_1110": "应为类型。",
  "A_class_member_cannot_be_declared_optional_1112": "不能将类成员声明为可选。",
  "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113": "\"default\" 子句在 \"switch\" 语句中只能出现一次。",
  "Duplicate_label_0_1114": "标签“{0}”重复",
  "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115": "\"continue\" 语句只能跳转到封闭迭代语句的标签。",
  "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116": "\"break\" 语句只能跳转到封闭语句的标签。",
  "An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode_1117": "严格模式下，对象文字不能包含多个具有相同名称的属性。",
  "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118": "对象文字不能具有多个具有相同名称的 get/set 访问器。",
  "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119": "对象文字不能包含具有相同名称的属性和访问器。",
  "An_export_assignment_cannot_have_modifiers_1120": "导出分配不能具有修饰符。",
  "Octal_literals_are_not_allowed_in_strict_mode_1121": "严格模式下不允许使用八进制文本。",
  "A_tuple_type_element_list_cannot_be_empty_1122": "元组类型元素列表不能为空。",
  "Variable_declaration_list_cannot_be_empty_1123": "变量声明列表不能为空。",
  "Digit_expected_1124": "应为数字。",
  "Hexadecimal_digit_expected_1125": "应为十六进制数字。",
  "Unexpected_end_of_text_1126": "文本意外结束。",
  "Invalid_character_1127": "无效的字符。",
  "Declaration_or_statement_expected_1128": "应为声明或语句。",
  "Statement_expected_1129": "应为语句。",
  "case_or_default_expected_1130": "应为 \"case\" 或 \"default\"。",
  "Property_or_signature_expected_1131": "应为属性或签名。",
  "Enum_member_expected_1132": "应为枚举成员。",
  "Variable_declaration_expected_1134": "应为变量声明。",
  "Argument_expression_expected_1135": "应为参数表达式。",
  "Property_assignment_expected_1136": "应为属性分配。",
  "Expression_or_comma_expected_1137": "应为表达式或逗号。",
  "Parameter_declaration_expected_1138": "应为参数声明。",
  "Type_parameter_declaration_expected_1139": "应为类型参数声明。",
  "Type_argument_expected_1140": "应为类型参数。",
  "String_literal_expected_1141": "应为字符串文本。",
  "Line_break_not_permitted_here_1142": "不允许在此处换行。",
  "or_expected_1144": "应为 \"{\" 或 \";\"。",
  "Modifiers_not_permitted_on_index_signature_members_1145": "不允许对索引签名成员使用修饰符。",
  "Declaration_expected_1146": "应为声明。",
  "Import_declarations_in_a_namespace_cannot_reference_a_module_1147": "命名空间中的导入声明不能引用模块。",
  "Cannot_compile_modules_unless_the_module_flag_is_provided_with_a_valid_module_type_Consider_setting__1148": "Cannot compile modules unless the '--module' flag is provided with a valid module type. Consider setting the 'module' compiler option in a 'tsconfig.json' file.",
  "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149": "文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同",
  "new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead_1150": "\"new T[]\" 不能用于创建数组。请改用 \"new Array<T>()\"。",
  "const_declarations_must_be_initialized_1155": "必须初始化 \"const\" 声明",
  "const_declarations_can_only_be_declared_inside_a_block_1156": "\"const\" 声明只能在块的内部声明。",
  "let_declarations_can_only_be_declared_inside_a_block_1157": "\"let\" 声明只能在块的内部声明。",
  "Unterminated_template_literal_1160": "未终止的模板文本。",
  "Unterminated_regular_expression_literal_1161": "未终止的正则表达式文本。",
  "An_object_member_cannot_be_declared_optional_1162": "对象成员无法声明为可选。",
  "A_yield_expression_is_only_allowed_in_a_generator_body_1163": "只允许在生成器正文中使用 \"yield\" 表达式。",
  "Computed_property_names_are_not_allowed_in_enums_1164": "枚举中不允许计算属性名。",
  "A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol_1165": "环境上下文中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol_1166": "类属性声明中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol_1168": "方法重载中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol_1169": "接口中的计算属性名必须直接引用内置符号。",
  "A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol_1170": "类型文本中的计算属性名必须直接引用内置符号。",
  "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171": "计算属性名中不允许逗号表达式。",
  "extends_clause_already_seen_1172": "已看到 \"extends\" 子句。",
  "extends_clause_must_precede_implements_clause_1173": "\"extends\" 子句必须位于 \"implements\" 子句之前。",
  "Classes_can_only_extend_a_single_class_1174": "类只能扩展一个类。",
  "implements_clause_already_seen_1175": "已看到 \"implements\" 子句。",
  "Interface_declaration_cannot_have_implements_clause_1176": "接口声明不能有 \"implements\" 子句。",
  "Binary_digit_expected_1177": "需要二进制数字。",
  "Octal_digit_expected_1178": "需要八进制数字。",
  "Unexpected_token_expected_1179": "意外标记。应为 \"{\"。",
  "Property_destructuring_pattern_expected_1180": "应为属性析构模式。",
  "Array_element_destructuring_pattern_expected_1181": "应为数组元素析构模式。",
  "A_destructuring_declaration_must_have_an_initializer_1182": "析构声明必须具有初始化表达式。",
  "An_implementation_cannot_be_declared_in_ambient_contexts_1183": "不能在环境上下文中声明实现。",
  "Modifiers_cannot_appear_here_1184": "修饰符不能出现在此处。",
  "Merge_conflict_marker_encountered_1185": "遇到合并冲突标记。",
  "A_rest_element_cannot_have_an_initializer_1186": "rest 元素不能具有初始化表达式。",
  "A_parameter_property_may_not_be_a_binding_pattern_1187": "参数属性不能为绑定模式。",
  "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188": "\"for...of\" 语句中只允许单个变量声明。",
  "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189": "\"for...in\" 语句的变量声明不能有初始化表达式。",
  "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190": "\"for...of\" 语句的变量声明不能有初始化表达式。",
  "An_import_declaration_cannot_have_modifiers_1191": "导入声明不能有修饰符。",
  "Module_0_has_no_default_export_1192": "模块“{0}”没有默认导出。",
  "An_export_declaration_cannot_have_modifiers_1193": "导出声明不能有修饰符。",
  "Export_declarations_are_not_permitted_in_a_namespace_1194": "命名空间中不允许有导出声明。",
  "Catch_clause_variable_name_must_be_an_identifier_1195": "Catch 子句变量名称必须是一个标识符。",
  "Catch_clause_variable_cannot_have_a_type_annotation_1196": "Catch 子句变量不能有类型批注。",
  "Catch_clause_variable_cannot_have_an_initializer_1197": "Catch 子句变量不能有初始化表达式。",
  "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198": "扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。",
  "Unterminated_Unicode_escape_sequence_1199": "未终止的 Unicode 转义序列。",
  "Line_terminator_not_permitted_before_arrow_1200": "箭头前不允许有行终止符。",
  "Import_assignment_cannot_be_used_when_targeting_ECMAScript_6_modules_Consider_using_import_Asterisk__1202": "当面向 ECMAScript 6 模块时，不能使用导入分配。请考虑改用 \"import * as ns from \"mod\"\" 、\"import {a} from \"mod\"\" 或 \"import d from \"mod\"\" 或其他模块格式。",
  "Export_assignment_cannot_be_used_when_targeting_ECMAScript_6_modules_Consider_using_export_default_o_1203": "当面向 ECMAScript 6 模块时，不能使用导出分配。请考虑改用“导出默认”或其他模块格式。",
  "Cannot_compile_modules_into_es2015_when_targeting_ES5_or_lower_1204": "在面向 \"ES5\" 或更低版本时无法将编译到 \"es2015\" 中。",
  "Decorators_are_not_valid_here_1206": "修饰器在此处无效。",
  "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207": "不能向多个同名的 get/set 访问器应用修饰器。",
  "Cannot_compile_namespaces_when_the_isolatedModules_flag_is_provided_1208": "提供 \"--isolatedModules\" 标志时无法编译命名空间。",
  "Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided_1209": "提供 \"--isolatedModules\" 标志的情况下不允许使用环境常数枚举。",
  "Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode_1210": "“{0}”的使用无效。类定义自动处于严格模式。",
  "A_class_declaration_without_the_default_modifier_must_have_a_name_1211": "不带 \"default\" 修饰符的类声明必须具有名称",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212": "应为标识符。“{0}”在严格模式下是保留字",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213": "应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。",
  "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214": "应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。",
  "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215": "“{0}”的使用无效。模块自动处于严格模式。",
  "Export_assignment_is_not_supported_when_module_flag_is_system_1218": "当 \"--module\" 标志是 \"system\" 时不支持导出分配。",
  "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219": "Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.",
  "Generators_are_only_available_when_targeting_ECMAScript_6_or_higher_1220": "仅当面向 ECMAScript 6 或更高版本时，生成器才可用。",
  "Generators_are_not_allowed_in_an_ambient_context_1221": "不允许在环境上下文中使用生成器。",
  "An_overload_signature_cannot_be_declared_as_a_generator_1222": "重载签名无法声明为生成器。",
  "_0_tag_already_specified_1223": "已指定“{0}”标记。",
  "Signature_0_must_have_a_type_predicate_1224": "签名“{0}”必须具有类型谓词。",
  "Cannot_find_parameter_0_1225": "找不到参数“{0}”。",
  "Type_predicate_0_is_not_assignable_to_1_1226": "类型谓词“{0}”不可分配给“{1}”。",
  "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227": "参数“{0}”和参数“{1}”的位置不一样。",
  "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228": "只允许在函数和方法的返回类型位置使用类型谓词。",
  "A_type_predicate_cannot_reference_a_rest_parameter_1229": "类型谓词无法引用 rest 参数。",
  "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230": "类型谓词无法在绑定模式中引用元素“{0}”。",
  "An_export_assignment_can_only_be_used_in_a_module_1231": "导出分配只能在模块中使用。",
  "An_import_declaration_can_only_be_used_in_a_namespace_or_module_1232": "导入声明只能在命名空间或模块中使用。",
  "An_export_declaration_can_only_be_used_in_a_module_1233": "导出声明只能在模块中使用。",
  "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234": "只允许在文件的顶层中使用环境模块声明。",
  "A_namespace_declaration_is_only_allowed_in_a_namespace_or_module_1235": "只允许在命名空间或模块中使用命名空间声明。",
  "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236": "属性修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237": "参数修饰器函数的返回类型必须为 \"void\" 或 \"any\"。",
  "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238": "作为表达式调用时，无法解析类修饰器的签名。",
  "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239": "作为表达式调用时，无法解析参数修饰器的签名。",
  "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240": "作为表达式调用时，无法解析属性修饰器的签名。",
  "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241": "作为表达式调用时，无法解析方法修饰器的签名。",
  "abstract_modifier_can_only_appear_on_a_class_or_method_declaration_1242": "\"abstract\" 修饰符只能出现在类声明或方法声明中。",
  "_0_modifier_cannot_be_used_with_1_modifier_1243": "“{0}”修饰符不能与“{1}”修饰符一起使用。",
  "Abstract_methods_can_only_appear_within_an_abstract_class_1244": "抽象方法只能出现在抽象类中。",
  "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245": "方法“{0}”不能具有实现，因为它标记为抽象。",
  "An_interface_property_cannot_have_an_initializer_1246": "接口函数不能具有初始化表达式。",
  "A_type_literal_property_cannot_have_an_initializer_1247": "类型文字数据不可具有初始化表达式。",
  "A_class_member_cannot_have_the_0_keyword_1248": "A class member cannot have the '{0}' keyword.",
  "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249": "A decorator can only decorate a method implementation, not an overload.",
  "with_statements_are_not_allowed_in_an_async_function_block_1300": "不允许在异步函数块中使用 \"with\" 语句。",
  "await_expression_is_only_allowed_within_an_async_function_1308": "只允许在异步函数中使用 \"await\" 表达式。",
  "Async_functions_are_only_available_when_targeting_ECMAScript_6_and_higher_1311": "仅当面向 ECMAScript 6 和更高版本时，异步函数才可用。",
  "can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment_1312": "\"=\" 只可在重构赋值内部的对象文字属性中使用。",
  "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313": "\"if\" 语句的正文不能为空语句。",
  "Duplicate_identifier_0_2300": "标识符“{0}”重复。",
  "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301": "实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。",
  "Static_members_cannot_reference_class_type_parameters_2302": "静态成员不能引用类类型参数。",
  "Circular_definition_of_import_alias_0_2303": "导入别名“{0}”的循环定义。",
  "Cannot_find_name_0_2304": "找不到名称“{0}”。",
  "Module_0_has_no_exported_member_1_2305": "模块“{0}”没有导出的成员“{1}”。",
  "File_0_is_not_a_module_2306": "文件“{0}”不是模块。",
  "Cannot_find_module_0_2307": "找不到模块“{0}”。",
  "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308": "模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。",
  "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309": "不能在具有其他导出元素的模块中使用导出分配。",
  "Type_0_recursively_references_itself_as_a_base_type_2310": "类型“{0}”以递归方式将自身引用为基类。",
  "A_class_may_only_extend_another_class_2311": "类只能扩展其他类。",
  "An_interface_may_only_extend_a_class_or_another_interface_2312": "接口只能扩展类或其他接口。",
  "Type_parameter_0_has_a_circular_constraint_2313": "Type parameter '{0}' has a circular constraint.",
  "Generic_type_0_requires_1_type_argument_s_2314": "泛型类型“{0}”需要 {1} 个类型参数。",
  "Type_0_is_not_generic_2315": "类型“{0}”不是泛型类型。",
  "Global_type_0_must_be_a_class_or_interface_type_2316": "全局类型“{0}”必须为类或接口类型。",
  "Global_type_0_must_have_1_type_parameter_s_2317": "全局类型“{0}”必须具有 {1} 个类型参数。",
  "Cannot_find_global_type_0_2318": "找不到全局类型“{0}”。",
  "Named_property_0_of_types_1_and_2_are_not_identical_2319": "“{1}”和“{2}”类型的命名属性“{0}”不完全相同。",
  "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320": "接口“{0}”不能同时扩展类型“{1}”和“{2}”。",
  "Excessive_stack_depth_comparing_types_0_and_1_2321": "与类型“{0}”和“{1}”相比，堆栈深度过高。",
  "Type_0_is_not_assignable_to_type_1_2322": "不能将类型“{0}”分配给类型“{1}”。",
  "Cannot_redeclare_exported_variable_0_2323": "无法重新声明导出的变量“{0}”。",
  "Property_0_is_missing_in_type_1_2324": "类型“{1}”中缺少属性“{0}”。",
  "Property_0_is_private_in_type_1_but_not_in_type_2_2325": "属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。",
  "Types_of_property_0_are_incompatible_2326": "属性“{0}”的类型不兼容。",
  "Property_0_is_optional_in_type_1_but_required_in_type_2_2327": "属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。",
  "Types_of_parameters_0_and_1_are_incompatible_2328": "参数“{0}”和“{1}” 的类型不兼容。",
  "Index_signature_is_missing_in_type_0_2329": "类型“{0}”中缺少索引签名。",
  "Index_signatures_are_incompatible_2330": "索引签名不兼容。",
  "this_cannot_be_referenced_in_a_module_or_namespace_body_2331": "不能在模块或命名空间体中引用 \"this\"。",
  "this_cannot_be_referenced_in_current_location_2332": "不能在当前位置引用 \"this\"。",
  "this_cannot_be_referenced_in_constructor_arguments_2333": "不能在构造函数参数中引用 \"this\"。",
  "this_cannot_be_referenced_in_a_static_property_initializer_2334": "不能在静态属性初始化表达式中引用 \"this\"。",
  "super_can_only_be_referenced_in_a_derived_class_2335": "只能在派生类中引用 \"super\"。",
  "super_cannot_be_referenced_in_constructor_arguments_2336": "不能在构造函数参数中引用 \"super\"。",
  "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337": "不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。",
  "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338": "只有构造函数、成员函数或派生类的成员访问器中才允许 \"super\" 属性访问。",
  "Property_0_does_not_exist_on_type_1_2339": "类型“{1}”上不存在属性“{0}”。",
  "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340": "通过 \"super\" 关键字只能访问基类的公共方法和受保护方法。",
  "Property_0_is_private_and_only_accessible_within_class_1_2341": "属性“{0}”为私有属性，只能在类“{1}”中访问。",
  "An_index_expression_argument_must_be_of_type_string_number_symbol_or_any_2342": "索引表达式参数必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\" 类型。",
  "Type_0_does_not_satisfy_the_constraint_1_2344": "类型“{0}”不满足约束“{1}”。",
  "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345": "类型“{0}”的参数不能赋给类型“{1}”的参数。",
  "Supplied_parameters_do_not_match_any_signature_of_call_target_2346": "提供的参数与调用目标的任何签名都不匹配。",
  "Untyped_function_calls_may_not_accept_type_arguments_2347": "非类型化函数调用不能接受类型参数。",
  "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348": "类型“{0}”的值不可调用。是否希望包括 \"new\"?",
  "Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_2349": "无法调用其类型缺少调用签名的表达式。",
  "Only_a_void_function_can_be_called_with_the_new_keyword_2350": "使用 \"new\" 关键字只能调用 void 函数。",
  "Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature_2351": "其类型缺少调用或构造签名的表达式无法使用 \"new\"。",
  "Neither_type_0_nor_type_1_is_assignable_to_the_other_2352": "类型“{0}”和类型“{1}”均不能赋给对方。",
  "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353": "对象文字可以只指定已知属性，并且“{0}”不在类型“{1}”中。",
  "No_best_common_type_exists_among_return_expressions_2354": "返回表达式中不存在最佳通用类型。",
  "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355": "其声明类型不为 \"void\" 或 \"any\" 的函数必须返回值。",
  "An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type_2356": "算术操作数必须为类型 \"any\"、\"number\" 或枚举类型。",
  "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer_2357": "增量或减量运算符的操作数必须为变量、属性或索引器。",
  "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358": "\"instanceof\" 表达式左侧必须是 \"any\" 类型、对象类型或类型参数。",
  "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359": "\"instanceof\" 表达式的右侧必须属于类型 \"any\"，或属于可分配给 \"Function\" 接口类型的类型。",
  "The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol_2360": "\"in\" 表达式左侧的类型必须为 \"any\"、\"string\"、\"number\" 或 \"symbol\"。",
  "The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter_2361": "\"in\" 表达式的右侧必须是 \"any\" 类型、对象类型或类型参数",
  "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2362": "算术运算左侧必须是 \"any\"、\"number\" 或枚举类型。",
  "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type_2363": "算术运算右侧必须是 \"any\"、\"number\" 或枚举类型。",
  "Invalid_left_hand_side_of_assignment_expression_2364": "赋值表达式左侧无效。",
  "Operator_0_cannot_be_applied_to_types_1_and_2_2365": "运算符“{0}”不能应用于类型“{1}”和“{2}”。",
  "Type_parameter_name_cannot_be_0_2368": "类型参数名称不能为“{0}”",
  "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369": "只允许在构造函数实现中使用参数属性。",
  "A_rest_parameter_must_be_of_an_array_type_2370": "rest 参数必须是数组类型。",
  "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371": "只允许在函数或构造函数实现中使用参数初始化表达式。",
  "Parameter_0_cannot_be_referenced_in_its_initializer_2372": "参数“{0}”的初始化表达式中不能引用该参数自身。",
  "Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it_2373": "参数“{0}”的初始化表达式不能引用在它之后声明的标识符“{1}”。",
  "Duplicate_string_index_signature_2374": "字符串索引签名重复。",
  "Duplicate_number_index_signature_2375": "数字索引签名重复。",
  "A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_proper_2376": "当类包含初始化的属性或参数属性时，\"super\" 调用必须是构造函数中的第一个语句。",
  "Constructors_for_derived_classes_must_contain_a_super_call_2377": "派生类的构造函数必须包含 \"super\" 调用。",
  "A_get_accessor_must_return_a_value_2378": "\"get\" 访问器必须返回值。",
  "Getter_and_setter_accessors_do_not_agree_in_visibility_2379": "Getter 和 setter 访问器在可见性上不一致。",
  "get_and_set_accessor_must_have_the_same_type_2380": "\"get\" 和 \"set\" 访问器必须属于同一类型。",
  "A_signature_with_an_implementation_cannot_use_a_string_literal_type_2381": "具有实现的签名不能使用字符串文本类型。",
  "Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature_2382": "指定的重载签名不可分配给任何非专用化签名。",
  "Overload_signatures_must_all_be_exported_or_not_exported_2383": "重载签名必须全部导出或全部不导出。",
  "Overload_signatures_must_all_be_ambient_or_non_ambient_2384": "重载签名必须全部为环境签名或非环境签名。",
  "Overload_signatures_must_all_be_public_private_or_protected_2385": "重载签名必须全部是公共签名、私有签名或受保护签名。",
  "Overload_signatures_must_all_be_optional_or_required_2386": "重载签名必须全部为可选签名或必需签名。",
  "Function_overload_must_be_static_2387": "函数重载必须为静态。",
  "Function_overload_must_not_be_static_2388": "函数重载不能为静态。",
  "Function_implementation_name_must_be_0_2389": "函数实现名称必须为“{0}”。",
  "Constructor_implementation_is_missing_2390": "缺少构造函数实现。",
  "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391": "函数实现缺失或未立即出现在声明之后。",
  "Multiple_constructor_implementations_are_not_allowed_2392": "不允许存在多个构造函数实现。",
  "Duplicate_function_implementation_2393": "函数实现重复。",
  "Overload_signature_is_not_compatible_with_function_implementation_2394": "重载签名与函数实现不兼容。",
  "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395": "合并声明“{0}”中的单独声明必须全为导出或全为局部声明。",
  "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396": "标识符 \"arguments\" 重复。编译器使用 \"arguments\" 初始化 rest 参数。",
  "Declaration_name_conflicts_with_built_in_global_identifier_0_2397": "Declaration name conflicts with built-in global identifier '{0}'.",
  "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399": "标识符 \"_this\" 重复。编译器使用变量声明 \"_this\" 来捕获 \"this\" 引用。",
  "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400": "表达式解析为编译器用于捕获 \"this\" 引用的变量声明 \"_this\"。",
  "Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference_2401": "标识符 \"_super\" 重复。编译器使用 \"_super\" 获取基类引用。",
  "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402": "表达式解析为 \"_super\"，编译器使用 \"_super\" 获取基类引用。",
  "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403": "后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。",
  "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404": "\"for...in\" 语句的左侧不能使用类型批注。",
  "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405": "\"for...in\" 语句的左侧必须是 \"string\" 或 \"any\" 类型。",
  "Invalid_left_hand_side_in_for_in_statement_2406": "\"for...in\" 语句左侧无效。",
  "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_2407": "\"for...in\" 语句右侧必须是 \"any\" 类型、对象类型或类型参数。",
  "Setters_cannot_return_a_value_2408": "Setter 不能返回值。",
  "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409": "构造函数签名的返回类型必须可赋给类的实例类型",
  "All_symbols_within_a_with_block_will_be_resolved_to_any_2410": "\"with\" 块内的所有符号都将被解析为 \"any\"。",
  "Property_0_of_type_1_is_not_assignable_to_string_index_type_2_2411": "类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。",
  "Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2_2412": "类型“{1}”的属性“{0}”不能赋给数值索引类型“{2}”。",
  "Numeric_index_type_0_is_not_assignable_to_string_index_type_1_2413": "数字索引类型“{0}”不能赋给字符串索引类型“{1}”。",
  "Class_name_cannot_be_0_2414": "类名不能为“{0}”",
  "Class_0_incorrectly_extends_base_class_1_2415": "类“{0}”错误扩展基类“{1}”。",
  "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417": "类静态侧“{0}”错误扩展基类静态侧“{1}”。",
  "Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0_2419": "extends 子句中的类型名称“{0}”不能引用“{0}”的构造函数。",
  "Class_0_incorrectly_implements_interface_1_2420": "类“{0}”错误实现接口“{1}”。",
  "A_class_may_only_implement_another_class_or_interface_2422": "类只能实现其他类或接口。",
  "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。",
  "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_proper_2424": "类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。",
  "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425": "类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。",
  "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426": "类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。",
  "Interface_name_cannot_be_0_2427": "接口名不能为“{0}”",
  "All_declarations_of_an_interface_must_have_identical_type_parameters_2428": "接口的所有声明必须具有相同的类型参数。",
  "Interface_0_incorrectly_extends_interface_1_2430": "接口“{0}”错误扩展接口“{1}”。",
  "Enum_name_cannot_be_0_2431": "枚举名不能为“{0}”",
  "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432": "在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。",
  "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433": "命名空间声明不能位于与之合并的类或函数中的其他文件内",
  "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434": "命名空间声明不能位于与之合并的类或函数前",
  "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435": "环境模块不能嵌套在其他模块或命名空间中。",
  "Ambient_module_declaration_cannot_specify_relative_module_name_2436": "环境模块声明无法指定相对模块名。",
  "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437": "模块“{0}”被具有相同名称的局部声明隐藏",
  "Import_name_cannot_be_0_2438": "导入名称不能为“{0}”",
  "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439": "环境模块声明中的导入或导出声明不能通过相对模块名引用模块。",
  "Import_declaration_conflicts_with_local_declaration_of_0_2440": "导入声明与“{0}”的局部声明冲突",
  "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441": "标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。",
  "Types_have_separate_declarations_of_a_private_property_0_2442": "类型具有私有属性“{0}”的单独声明。",
  "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443": "属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。",
  "Property_0_is_protected_in_type_1_but_public_in_type_2_2444": "属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。",
  "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445": "属性“{0}”受保护，只能在类“{1}”及其子类中访问。",
  "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_2446": "属性“{0}”受保护，只能通过类“{1}”的实例访问。",
  "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447": "“{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。",
  "Block_scoped_variable_0_used_before_its_declaration_2448": "声明之前已使用的块范围变量“{0}”。",
  "The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant_2449": "增量或减量运算符的操作数不能为常数。",
  "Left_hand_side_of_assignment_expression_cannot_be_a_constant_2450": "赋值表达式的左侧不能为常数。",
  "Cannot_redeclare_block_scoped_variable_0_2451": "无法重新声明块范围变量“{0}”。",
  "An_enum_member_cannot_have_a_numeric_name_2452": "枚举成员不能具有数值名。",
  "The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_typ_2453": "无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。",
  "Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0_2455": "候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。",
  "Type_alias_0_circularly_references_itself_2456": "类型别名“{0}”循环引用自身。",
  "Type_alias_name_cannot_be_0_2457": "类型别名不能为“{0}”",
  "An_AMD_module_cannot_have_multiple_name_assignments_2458": "AMD 模块无法拥有多个名称分配。",
  "Type_0_has_no_property_1_and_no_string_index_signature_2459": "类型“{0}”不具有属性“{1}”和字符串索引签名。",
  "Type_0_has_no_property_1_2460": "类型“{0}”不具有属性“{1}”。",
  "Type_0_is_not_an_array_type_2461": "类型“{0}”不是数组类型。",
  "A_rest_element_must_be_last_in_an_array_destructuring_pattern_2462": "rest 元素必须在数组析构模式中位于最末",
  "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463": "绑定模式参数在实现签名中不能为可选参数。",
  "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464": "计算属性名的类型必须为 \"string\"、\"number\"、\"symbol\" 或 \"any\"。",
  "this_cannot_be_referenced_in_a_computed_property_name_2465": "不能在计算属性名中引用 \"this\"。",
  "super_cannot_be_referenced_in_a_computed_property_name_2466": "不能在计算属性名中引用 \"super\"。",
  "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467": "计算属性名无法从其包含的类型引用类型参数。",
  "Cannot_find_global_value_0_2468": "找不到全局值“{0}”。",
  "The_0_operator_cannot_be_applied_to_type_symbol_2469": "“{0}”运算符不能应用于类型 \"symbol\"。",
  "Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object_2470": "\"Symbol\" 引用不是指全局符号构造函数对象。",
  "A_computed_property_name_of_the_form_0_must_be_of_type_symbol_2471": "窗体“{0}”的计算属性名必须是 \"symbol\" 类型。",
  "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472": "仅当面向 ECMAScript 5 和更高版本时，\"new\" 表达式中的展开运算符才可用。",
  "Enum_declarations_must_all_be_const_or_non_const_2473": "枚举声明必须全为常数或非常数。",
  "In_const_enum_declarations_member_initializer_must_be_constant_expression_2474": "在 \"const\" 枚举声明中，成员初始化表达式必须是常数表达式。",
  "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475": "\"const\" 枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。",
  "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476": "只有使用字符串文本才能访问常数枚举成员。",
  "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477": "\"const\" 枚举成员初始化表达式的求值结果为非有限值。",
  "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478": "\"const\" 枚举成员初始化表达式的求值结果为不允许使用的值 \"NaN\"。",
  "Property_0_does_not_exist_on_const_enum_1_2479": "\"const\" 枚举“{1}”上不存在属性“{0}”。",
  "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480": "\"let\" 不能用作 \"let\" 或 \"const\" 声明中的名称。",
  "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481": "无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。",
  "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483": "\"for...of\" 语句的左侧不能使用类型批注。",
  "Export_declaration_conflicts_with_exported_declaration_of_0_2484": "导出声明与“{0}”的导出声明冲突",
  "The_left_hand_side_of_a_for_of_statement_cannot_be_a_previously_defined_constant_2485": "\"for...of\" 语句的左侧不能是以前定义的常数。",
  "The_left_hand_side_of_a_for_in_statement_cannot_be_a_previously_defined_constant_2486": "\"for...in\" 语句的左侧不能是以前定义的常数。",
  "Invalid_left_hand_side_in_for_of_statement_2487": "\"for...of\" 语句左侧无效。",
  "Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488": "类型必须具有返回迭代器的 \"[Symbol.iterator]()\" 方法。",
  "An_iterator_must_have_a_next_method_2489": "迭代器必须具有 \"next()\" 方法。",
  "The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property_2490": "迭代器的 \"next()\" 方法返回的类型必须具有 \"value\" 属性。",
  "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491": "\"for...in\" 语句的左侧不能为析构模式。",
  "Cannot_redeclare_identifier_0_in_catch_clause_2492": "无法在 catch 子句中重新声明标识符“{0}”",
  "Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2_2493": "不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。",
  "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494": "仅 ECMAScript 5 和更高版本支持在 \"for...of\" 语句中使用字符串。",
  "Type_0_is_not_an_array_type_or_a_string_type_2495": "类型“{0}”不是数组类型或字符串类型。",
  "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496": "ES3 和 ES5 中的箭头函数不能引用 \"arguments\" 对象。请考虑使用标准函数表达式。",
  "Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct_2497": "模块“{0}”解析为非模块实体，且不能使用此构造导入。",
  "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498": "模块“{0}”使用 \"export =\" 且无法与 \"export *\" 一起使用。",
  "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499": "接口只能扩展具有可选类型参数的标识符/限定名称。",
  "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500": "类只能实现具有可选类型参数的标识符/限定名称。",
  "A_rest_element_cannot_contain_a_binding_pattern_2501": "rest 元素不能包含绑定模式。",
  "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502": "“{0}”在其自身的类型批注中得到直接或间接引用。",
  "Cannot_find_namespace_0_2503": "找不到命名空间“{0}”。",
  "No_best_common_type_exists_among_yield_expressions_2504": "yield 表达式中不存在最佳通用类型。",
  "A_generator_cannot_have_a_void_type_annotation_2505": "生成器不能具有 \"void\" 类型批注。",
  "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506": "“{0}”在其自身的基表达式中得到直接或间接引用。",
  "Type_0_is_not_a_constructor_function_type_2507": "类型“{0}”不是构造函数类型。",
  "No_base_constructor_has_the_specified_number_of_type_arguments_2508": "没有任何基构造函数具有指定数量的类型参数。",
  "Base_constructor_return_type_0_is_not_a_class_or_interface_type_2509": "基构造函数返回类型“{0}”不是类或接口类型。",
  "Base_constructors_must_all_have_the_same_return_type_2510": "所有的基构造函数必须具有相同的返回类型。",
  "Cannot_create_an_instance_of_the_abstract_class_0_2511": "无法创建抽象类“{0}”的实例。",
  "Overload_signatures_must_all_be_abstract_or_not_abstract_2512": "重载签名必须全部为抽象签名或非抽象签名。",
  "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513": "无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。",
  "Classes_containing_abstract_methods_must_be_marked_abstract_2514": "包含抽象方法的类必须标记为抽象。",
  "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515": "非抽象类“{0}”不会实现继承自“{2}”类的抽象成员“{1}”。",
  "All_declarations_of_an_abstract_method_must_be_consecutive_2516": "抽象方法的所有声明必须是连续的。",
  "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517": "无法将抽象构造函数类型分配给非抽象构造函数类型。",
  "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518": "A 'this'-based type guard is not compatible with a parameter-based type guard.",
  "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520": "标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。",
  "Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions_2521": "表达式解析为编译器用于支持异步函数的变量声明“{0}”。",
  "The_arguments_object_cannot_be_referenced_in_an_async_arrow_function_Consider_using_a_standard_async_2522": "无法在异步箭头函数中引用 \"arguments\" 对象。请考虑使用标准的异步函数表达式。",
  "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523": "不能在参数初始化表达式中使用 \"yield\" 表达式。",
  "await_expressions_cannot_be_used_in_a_parameter_initializer_2524": "不能在参数初始化表达式中使用 \"await\" 表达式。",
  "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525": "初始化表达式没有为此绑定元素提供此任何值，且该绑定元素没有默认值。",
  "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526": "\"this\" 类型仅在类或接口的非静态成员中可用。",
  "The_inferred_type_of_0_references_an_inaccessible_this_type_A_type_annotation_is_necessary_2527": "“{0}”的推断类型引用不可访问的 \"this\" 类型。需要类型批注。",
  "A_module_cannot_have_multiple_default_exports_2528": "一个模块不能具有多个默认导出。",
  "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529": "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.",
  "JSX_element_attributes_type_0_may_not_be_a_union_type_2600": "JSX element attributes type '{0}' may not be a union type.",
  "The_return_type_of_a_JSX_element_constructor_must_return_an_object_type_2601": "JSX 元素构造函数的返回类型必须返回对象类型。",
  "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602": "JSX 元素隐式具有类型 \"any\"，因为不存在全局类型 \"JSX.Element\"。",
  "Property_0_in_type_1_is_not_assignable_to_type_2_2603": "类型“{1}”中的属性“{0}”不可分配给类型“{2}”",
  "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604": "JSX 元素类型“{0}”不具有任何构造签名或调用签名。",
  "JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements_2605": "JSX 元素类型“{0}”不是 JSX 元素的构造函数。",
  "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606": "JSX 展开特性的“{0}”属性不能分配给目标属性。",
  "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607": "JSX 元素类不支持特性，因为它不具有“{0}”属性",
  "The_global_type_JSX_0_may_not_have_more_than_one_property_2608": "全局类型“JSX.{0}”不可以具有多个属性",
  "Cannot_emit_namespaced_JSX_elements_in_React_2650": "无法发出 React 中带命名空间的 JSX 元素",
  "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651": "枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。",
  "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652": "合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。",
  "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653": "非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。",
  "Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_pack_2654": "导出的外部包键入文件不能包含三斜线引用。请与包作者联系或更新包定义。",
  "Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_2656": "导出的外部包键入文件“{0}”不是一个模块。请与包作者联系或更新包定义。",
  "JSX_expressions_must_have_one_parent_element_2657": "JSX 表达式必须具有一个父元素",
  "Type_0_provides_no_match_for_the_signature_1_2658": "类型“{0}”提供程序与签名“{1}”不匹配",
  "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659": "'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.",
  "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660": "'super' can only be referenced in members of derived classes or object literal expressions.",
  "Cannot_re_export_name_that_is_not_defined_in_the_module_2661": "Cannot re-export name that is not defined in the module.",
  "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662": "Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?",
  "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663": "Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?",
  "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664": "Invalid module name in augmentation, module '{0}' cannot be found.",
  "Module_augmentation_cannot_introduce_new_names_in_the_top_level_scope_2665": "Module augmentation cannot introduce new names in the top level scope.",
  "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666": "Exports and export assignments are not permitted in module augmentations.",
  "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667": "Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.",
  "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668": "'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.",
  "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669": "Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.",
  "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670": "Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.",
  "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671": "Cannot augment module '{0}' because it resolves to a non-module entity.",
  "Import_declaration_0_is_using_private_name_1_4000": "导入声明“{0}”使用的是专用名称“{1}”。",
  "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002": "导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004": "导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006": "导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008": "导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010": "导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012": "导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014": "导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016": "导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。",
  "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019": "导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。",
  "Extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020": "导出的类“{0}”的 extends 子句具有或正在使用专用名称“{1}”。",
  "Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022": "导出接口“{0}”的 extends 子句具有或正在使用专用名称“{1}”。",
  "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023": "导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024": "导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Exported_variable_0_has_or_is_using_private_name_1_4025": "导出的变量“{0}”具有或正在使用专用名称“{1}”。",
  "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027": "导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。",
  "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028": "导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。",
  "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029": "导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030": "导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031": "导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。",
  "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032": "导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033": "导出接口的属性“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_4034": "导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1_4035": "导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_4036": "导出类中的公共属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1_4037": "导出类中的公共属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_externa_4038": "导出类中的公共静态属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_4039": "导出类中的公共静态属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0_4040": "导出类中的公共静态属性 getter 的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_modul_4041": "导出类中的公共属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_4042": "导出类中的公共属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0_4043": "导出类中的公共属性 getter 的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044": "导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045": "导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046": "导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047": "导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048": "导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049": "导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050": "导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051": "导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052": "导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053": "导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054": "导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055": "导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056": "导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057": "导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。",
  "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058": "导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。",
  "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059": "导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。",
  "Return_type_of_exported_function_has_or_is_using_private_name_0_4060": "导出函数的返回类型具有或正在使用专用名称“{0}”。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061": "导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062": "导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063": "导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064": "导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065": "导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066": "导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067": "导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068": "导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069": "导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070": "导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071": "导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072": "导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073": "导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074": "导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075": "导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076": "导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。",
  "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077": "导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。",
  "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078": "导出函数的参数“{0}”具有或正在使用专用名称“{1}”。",
  "Exported_type_alias_0_has_or_is_using_private_name_1_4081": "导出的类型别名“{0}”已经或正在使用专用名称“{1}”。",
  "Default_export_of_the_module_has_or_is_using_private_name_0_4082": "模块的默认导出具有或正在使用专用名称“{0}”。",
  "The_current_host_does_not_support_the_0_option_5001": "当前主机不支持“{0}”选项。",
  "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009": "找不到输入文件的公共子目录路径。",
  "Cannot_read_file_0_Colon_1_5012": "无法读取文件“{0}”: {1}",
  "Unsupported_file_encoding_5013": "文件编码不受支持。",
  "Failed_to_parse_file_0_Colon_1_5014": "未能分析文件“{0}”: {1}。",
  "Unknown_compiler_option_0_5023": "未知的编译器选项“{0}”。",
  "Compiler_option_0_requires_a_value_of_type_1_5024": "编译器选项“{0}”需要类型 {1} 的值。",
  "Could_not_write_file_0_Colon_1_5033": "无法写入文件“{0}”: {1}",
  "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042": "选项 \"project\" 在命令行上不能与源文件混合使用。",
  "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047": "选项 \"isolatedModules\" 只可在提供了选项 \"--module\" 或者选项 \"target\" 是 \"ES2015\" 或更高版本时使用。",
  "Option_inlineSources_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_prov_5051": "仅当提供了选项 \"--inlineSources\" 或选项 \"--sourceMap\" 时，才能使用选项 \"inlineSources\"。",
  "Option_0_cannot_be_specified_without_specifying_option_1_5052": "无法在不指定选项“{1}”的情况下指定选项“{0}”。",
  "Option_0_cannot_be_specified_with_option_1_5053": "选项“{0}”不能与选项“{1}”同时指定。",
  "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054": "已在“{0}”中定义了 \"tsconfig.json\" 文件。",
  "Cannot_write_file_0_because_it_would_overwrite_input_file_5055": "无法写入文件“{0}”，因为它会覆盖输入文件。",
  "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056": "无法写入文件“{0}”，因为它会被多个输入文件覆盖。",
  "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057": "无法在指定目录找到 tsconfig.json 文件:“{0}”",
  "The_specified_path_does_not_exist_Colon_0_5058": "指定的路径不存在:“{0}”",
  "Invalide_value_for_reactNamespace_0_is_not_a_valid_identifier_5059": "Invalide value for '--reactNamespace'. '{0}' is not a valid identifier.",
  "Concatenate_and_emit_output_to_single_file_6001": "连接输出并将其发出到单个文件。",
  "Generates_corresponding_d_ts_file_6002": "生成相应的 \".d.ts\" 文件。",
  "Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6003": "指定调试程序应放置映射文件的位置而不是生成的位置。",
  "Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004": "指定调试程序应放置 TypeScript 文件的位置而不是源位置。",
  "Watch_input_files_6005": "监视输入文件。",
  "Redirect_output_structure_to_the_directory_6006": "将输出结构重定向到目录。",
  "Do_not_erase_const_enum_declarations_in_generated_code_6007": "请勿清除生成代码中的常数枚举声明。",
  "Do_not_emit_outputs_if_any_errors_were_reported_6008": "如果报告了任何错误，请不要发出输出。",
  "Do_not_emit_comments_to_output_6009": "请勿将注释发出到输出。",
  "Do_not_emit_outputs_6010": "请勿发出输出。",
  "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011": "允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。",
  "Specify_ECMAScript_target_version_Colon_ES3_default_ES5_or_ES2015_experimental_6015": "指定 ECMAScript 目标版本: \"ES3\" (默认)、\"ES5\" 或 \"ES2015\" (实验)",
  "Specify_module_code_generation_Colon_commonjs_amd_system_umd_or_es2015_6016": "指定模块代码生成: \"commonjs\"、\"amd\"、\"system\"、\"umd\" 或 \"es2015\"",
  "Print_this_message_6017": "打印此消息。",
  "Print_the_compiler_s_version_6019": "打印编译器的版本。",
  "Compile_the_project_in_the_given_directory_6020": "在指定目录中编译项目。",
  "Syntax_Colon_0_6023": "语法: {0}",
  "options_6024": "选项",
  "file_6025": "文件",
  "Examples_Colon_0_6026": "示例: {0}",
  "Options_Colon_6027": "选项:",
  "Version_0_6029": "版本 {0}",
  "Insert_command_line_options_and_files_from_a_file_6030": "从文件插入命令行选项和文件。",
  "File_change_detected_Starting_incremental_compilation_6032": "检测到文件更改。正在启动增量编译...",
  "KIND_6034": "种类",
  "FILE_6035": "文件",
  "VERSION_6036": "版本",
  "LOCATION_6037": "位置",
  "DIRECTORY_6038": "目录",
  "Compilation_complete_Watching_for_file_changes_6042": "编译完成。查看文件更改。",
  "Generates_corresponding_map_file_6043": "生成相应的 \".map\" 文件。",
  "Compiler_option_0_expects_an_argument_6044": "编译器选项“{0}”需要参数。",
  "Unterminated_quoted_string_in_response_file_0_6045": "响应文件“{0}”中引号不配对。",
  "Argument_for_module_option_must_be_commonjs_amd_system_umd_es2015_or_none_6046": "Argument for '--module' option must be 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'none'.",
  "Argument_for_target_option_must_be_ES3_ES5_or_ES2015_6047": "\"--target\" 选项的参数必须是 \"ES3\"、\"ES5\" 或 \"ES2015\"。",
  "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048": "区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。",
  "Unsupported_locale_0_6049": "区域设置“{0}”不受支持。",
  "Unable_to_open_file_0_6050": "无法打开文件“{0}”。",
  "Corrupted_locale_file_0_6051": "区域设置文件 {0} 已损坏。",
  "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052": "对具有隐式 \"any\" 类型的表达式和声明引发错误。",
  "File_0_not_found_6053": "找不到文件“{0}”。",
  "File_0_has_unsupported_extension_The_only_supported_extensions_are_1_6054": "不支持文件“{0}”的扩展名。唯一支持的扩展名为 {1}。",
  "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055": "抑制缺少索引签名的索引对象的 noImplicitAny 错误。",
  "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056": "请勿对具有 \"@internal\" 注释的代码发出声明。",
  "Specifies_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDi_6058": "指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。",
  "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059": "文件“{0}”不在 \"rootDir\"“{1}”下。\"rootDir\" 应包含所有源文件。",
  "Specifies_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060": "指定发出文件时要使用的行序列结尾: \"CRLF\" (dos)或 \"LF\" (unix)。",
  "NEWLINE_6061": "换行符",
  "Argument_for_newLine_option_must_be_CRLF_or_LF_6062": "\"--newLine\" 选项的参数必须是 \"CRLF\" 或 \"LF\"。",
  "Argument_for_moduleResolution_option_must_be_node_or_classic_6063": "\"--moduleResolution\" 选项的参数必须是 \"node\" 或 \"classic\"。",
  "Enables_experimental_support_for_ES7_decorators_6065": "对 ES7 修饰器启用实验支持。",
  "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066": "对发出修饰器的类型元数据启用实验支持。",
  "Enables_experimental_support_for_ES7_async_functions_6068": "对 ES7 异步函数启用实验支持。",
  "Specifies_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069": "指定模块解决策略: \"node\" (Node.js) 或 \"classic\" (TypeScript pre-1.6)。",
  "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070": "初始化 TypeScript 项目并创建 tsconfig.json 文件。",
  "Successfully_created_a_tsconfig_json_file_6071": "已成功创建 tsconfig.json 文件。",
  "Suppress_excess_property_checks_for_object_literals_6072": "取消对象文字的多余属性检查。",
  "Stylize_errors_and_messages_using_color_and_context_experimental_6073": "使用颜色和上下文风格化错误和消息。(实验)",
  "Do_not_report_errors_on_unused_labels_6074": "不报告有关未使用的标签的错误。",
  "Report_error_when_not_all_code_paths_in_function_return_a_value_6075": "在函数中的所有代码路径并非都返回值时报告错误。",
  "Report_errors_for_fallthrough_cases_in_switch_statement_6076": "报告 switch 语句中遇到 fallthrough 情况的错误。",
  "Do_not_report_errors_on_unreachable_code_6077": "不报告有关不可访问的代码的错误。",
  "Disallow_inconsistently_cased_references_to_the_same_file_6078": "不允许对同一文件采用大小不一致的引用。",
  "Specify_JSX_code_generation_Colon_preserve_or_react_6080": "指定 JSX 代码生成: \"preserve\" 或 \"react\"",
  "Argument_for_jsx_must_be_preserve_or_react_6081": "\"--jsx\" 的参数必须为 \"preserve\" 或 \"react\"。",
  "Only_amd_and_system_modules_are_supported_alongside_0_6082": "--{0} 旁仅支持 \"amd\" 和 \"system\" 模块。",
  "Allow_javascript_files_to_be_compiled_6083": "允许编译 JavaScript 文件。",
  "Specifies_the_object_invoked_for_createElement_and_spread_when_targeting_react_JSX_emit_6084": "Specifies the object invoked for createElement and __spread when targeting 'react' JSX emit",
  "Option_0_should_have_array_of_strings_as_a_value_6103": "Option '{0}' should have array of strings as a value.",
  "Do_not_emit_use_strict_directives_in_module_output_6112": "Do not emit 'use strict' directives in module output.",
  "Variable_0_implicitly_has_an_1_type_7005": "变量“{0}”隐式具有“{1}”类型。",
  "Parameter_0_implicitly_has_an_1_type_7006": "参数“{0}”隐式具有“{1}”类型。",
  "Member_0_implicitly_has_an_1_type_7008": "成员“{0}”隐式包含类型“{1}”。",
  "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009": "其目标缺少构造签名的 \"new\" 表达式隐式具有 \"any\" 类型。",
  "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010": "缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。",
  "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011": "缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。",
  "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013": "缺少返回类型批注的构造签名隐式具有返回类型 \"any\"。",
  "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015": "Element implicitly has an 'any' type because index expression is not of type 'number'.",
  "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation_7016": "属性“{0}”隐式具有类型 \"any\"，因为其 \"set\" 访问器缺少类型批注。",
  "Index_signature_of_object_type_implicitly_has_an_any_type_7017": "对象类型的索引签名隐式地含有 \"any\" 类型。",
  "Object_literal_s_property_0_implicitly_has_an_1_type_7018": "对象文字的属性“{0}”隐式含有“{1}”类型。",
  "Rest_parameter_0_implicitly_has_an_any_type_7019": "Rest 参数“{0}”隐式具有 \"any[]\" 类型。",
  "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020": "缺少返回类型批注的调用签名隐式具有返回类型 \"any\"。",
  "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022": "“{0}”隐式具有类型 \"any\"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。",
  "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023": "由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024": "由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 \"any\"。",
  "Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_typ_7025": "生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。",
  "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026": "JSX 元素隐式具有类型 \"any\"，因为不存在接口“JSX.{0}”",
  "Unreachable_code_detected_7027": "检测到无法访问的代码。",
  "Unused_label_7028": "未使用的标签。",
  "Fallthrough_case_in_switch_7029": "switch 语句中的 Fallthrough 情况。",
  "Not_all_code_paths_return_a_value_7030": "并非所有代码路径都返回值。",
  "You_cannot_rename_this_element_8000": "无法重命名此元素。",
  "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001": "不能重命名标准 TypeScript 库中定义的元素。",
  "import_can_only_be_used_in_a_ts_file_8002": "\"import ... =\" 只能在 .ts 文件中使用。",
  "export_can_only_be_used_in_a_ts_file_8003": "\"export=\" 只能在 .ts 文件中使用。",
  "type_parameter_declarations_can_only_be_used_in_a_ts_file_8004": "\"type parameter declarations\" 只能在 .ts 文件中使用。",
  "implements_clauses_can_only_be_used_in_a_ts_file_8005": "\"implements clauses\" 只能在 .ts 文件中使用。",
  "interface_declarations_can_only_be_used_in_a_ts_file_8006": "\"interface declarations\" 只能在 .ts 文件中使用。",
  "module_declarations_can_only_be_used_in_a_ts_file_8007": "\"module declarations\" 只能在 .ts 文件中使用。",
  "type_aliases_can_only_be_used_in_a_ts_file_8008": "\"type aliases\" 只能在 .ts 文件中使用。",
  "_0_can_only_be_used_in_a_ts_file_8009": "“{0}”只能在 .ts 文件中使用。",
  "types_can_only_be_used_in_a_ts_file_8010": "\"types\" 只能在 .ts 文件中使用。",
  "type_arguments_can_only_be_used_in_a_ts_file_8011": "\"type arguments\" 只能在 .ts 文件中使用。",
  "parameter_modifiers_can_only_be_used_in_a_ts_file_8012": "\"parameter modifiers\" 只能在 .ts 文件中使用。",
  "property_declarations_can_only_be_used_in_a_ts_file_8014": "\"property declarations\" 只能在 .ts 文件中使用。",
  "enum_declarations_can_only_be_used_in_a_ts_file_8015": "\"enum declarations\" 只能在 .ts 文件中使用。",
  "type_assertion_expressions_can_only_be_used_in_a_ts_file_8016": "\"type assertion expressions\" 只能在 .ts 文件中使用。",
  "Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_clas_9002": "类 \"extends\" 子句当前只支持具有可选类型参数的标识符/限定名称。",
  "class_expressions_are_not_currently_supported_9003": "当前不支持 \"class\" 表达式。",
  "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000": "只能为 JSX 属性分配非空“表达式”。",
  "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001": "JSX 元素不能具有多个名称相同的特性。",
  "Expected_corresponding_JSX_closing_tag_for_0_17002": "“{0}”预期的相应 JSX 结束标记。",
  "JSX_attribute_expected_17003": "需要 JSX 属性。",
  "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004": "无法使用 JSX，除非提供了 \"--jsx\" 标志。",
  "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005": "当构造函数的类扩展 \"null\" 时，它不能包含 \"super\" 调用。",
  "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006": "乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。",
  "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007": "乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。",
  "JSX_element_0_has_no_corresponding_closing_tag_17008": "JSX element '{0}' has no corresponding closing tag.",
  "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009": "'super' must be called before accessing 'this' in the constructor of a derived class.",
  "Unknown_typing_option_0_17010": "Unknown typing option '{0}'.",
  "Too_many_JavaScript_files_in_the_project_Consider_specifying_the_exclude_setting_in_project_configur_17012": "Too many JavaScript files in the project. Consider specifying the 'exclude' setting in project configuration to limit included source folders. The likely folder to exclude is '{0}'. To disable the project size limit, set the 'disableSizeLimit' compiler option to 'true'."
}